#第0章 引言

我1966年用Fortran写了我自己的第一个程序，试图计算并打印10000以内的斐波那契序列（就像 1，1，2，3，5，8，13，21...第二个数字之后的每个数字都是它前面两个数字的和），当然，它没能运行起来：
~~~
        I = 0
        J = 0        
        K = 1     
      1 PRINT 10, K        
        I = J        
        J = K        
        K = I + J        
        IF (K - 10000) 1, 1, 2      
      2 CALL EXIT     
     10 FORMAT (I 10)
~~~

Fortran 程序员很明显能看到这个程序没有END语句。后来我把END语句加上了，尽管如此，程序依然不能编译，只给出了一个神秘的错误信息：ERROR 6。

对手册仔细的阅读最终指出了问题所在：我所用的Fortran编译器无法处理四位数以上的整型常量。把10000改成9999就把问题解决了。

1977年我写了自己的第一个C程序。很自然地，它也没能跑起来：
    
    #include <stdio.h>

    main()
    { 
        printf("Hello world");
    }

这个程序一次就编译通过了。尽管结果有点奇特：终端的输出是类似这样的：
               
        % cc prog.c
        % a.out
        Hello world%


这里的%是系统提示符，是系统用来告诉我该我输入了时所显示的字符串。%紧接着Hello world是因为我忘记了告诉系统要开始一个新行。3.10节(51页)会讨论这个程序中一个极小的错误。

这两种程序之间真的有本质上的不同。Fortran的例子包含两个错误，但是Fortran很好地指出了这些错误。而那个C程序技术上来说是正确的——从机器的角度来说，它没有错误。因此也没有错误信息。机器精准无误地做到了我让它做的事，它只是没有完全按照我脑中所想的那样去做。

这本书关注第二种错误：程序没有按编程者原本期望的方式执行。除此之外，这本书会关注一些C语言中可能出现这种奇怪错误的方式。例如，看下面这段初始化一个大小为N的数组的程序：

        int i;
        int a[N];
        for (i = 0; i <= N; i++)
            a[i] = 0;

在很多C语言的实现上，这段程序会进入一个死循环。3.6节(36页)会说明为什么。

程序错误代表程序中脱离了编程者脑中的模型的地方。自然这种错误很难发现。我试着根据看待程序的方式和这些错误的关联给他们分类。

在底层的角度下，一个程序就是一个由*符号*或者*记号*组成的序列，就像一本书也只是一个单词序列。把程序分割成符号的过程叫做*词法分析*。第1章关注由C语言词法分析的方式所造成的问题。

还可以把程序看作语句和声明的序列，就像可以把书看作句子的序列一样。在这里，语义是由符号或单词如何组成更大的单元所体现的。第2章将关注那些由对于*语法*的歧义理解所造成的错误。

第3章关注语义误解：编程者本想表达一件事却可能实际上表达成另外一件。我们在这里假设*词法*和*句法*细节都被正确理解了，从而只关注*语义*细节。

第4章认识到一个C程序通常被分成几部分并分别编译，最后再组合在一起。这个过程被叫做*连接*，













