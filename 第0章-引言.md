#第0章 引言

我1966年用Fortran写了我自己的第一个程序，试图计算并打印10000以内的斐波那契序列（就像 1，1，2，3，5，8，13，21...第二个数字之后的每个数字都是它前面两个数字的和），当然，它没能运行起来：
~~~
        I = 0
        J = 0        
        K = 1     
      1 PRINT 10, K        
        I = J        
        J = K        
        K = I + J        
        IF (K - 10000) 1, 1, 2      
      2 CALL EXIT     
     10 FORMAT (I 10)
~~~

Fortran 程序员很明显能看到这个程序没有END语句。后来我把END语句加上了，尽管如此，程序依然不能编译，只给出了一个神秘的错误信息：ERROR 6。

对手册仔细的阅读最终指出了问题所在：我所用的Fortran编译器无法处理四位数以上的整型常量。把10000改成9999就把问题解决了。

1977年我写了自己的第一个C程序。很自然地，它也没能跑起来：
    
    #include <stdio.h>

    main()
    { 
        printf("Hello world");
    }

这个程序一次就编译通过了。尽管结果有点奇特：终端的输出是类似这样的：
               
        % cc prog.c
        % a.out
        Hello world%


这里的%是系统提示符，是系统用来告诉我该我输入了时所显示的字符串。%紧接着Hello world是因为我忘记了告诉系统要开始一个新行。3.10节(51页)会讨论这个程序中一个极小的错误。

这两种程序之间真的有本质上的不同。Fortran的例子包含两个错误，但是Fortran很好地指出了这些错误。而那个C程序技术上来说是正确的——从机器的角度来说，它没有错误。因此也没有错误信息。机器精准无误地做到了我让它做的事，它只是没有完全按照我脑中所想的那样去做。

这本书关注第二种错误：程序没有做编程者原本期望它做的事。除此之外，这本书也会关注一些C语言中可能出现的奇怪的错误。例如，看下面这段初始化一个大小为N的数组的程序：

        int i;
        int a[N];
        for (i = 0; i <= N; i++)
            a[i] = 0;

在很多C语言的实现上，这段程序会进入一个死循环。3.6节(36页)会说明为什么。

书第2页第7行，文档第一页，page51
